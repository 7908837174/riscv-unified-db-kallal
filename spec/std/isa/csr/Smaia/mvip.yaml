# Copyright (c) 2025 Kallal Mukherjee
# SPDX-License-Identifier: BSD-3-Clause-Clear

# yaml-language-server: $schema=../../../schemas/csr_schema.json

$schema: "csr_schema.json#"
kind: csr
name: mvip
long_name: Machine Virtual Interrupt Pending
address: 0x309
priv_mode: M
length: MXLEN
writable: true
description: |
  The `mvip` register contains the pending state of virtual interrupts. When the
  hart is executing in M-mode, these bits can be written by both software and
  external sources to set or clear the corresponding interrupt pending bits.
  
  If a bit in mvien is read-only zero, the corresponding bit in mvip should also be read-only zero.
definedBy: Smaia
fields:
  VSSIP:
    location: 1
    long_name: Virtual Supervisor Software Interrupt Pending
    description: |
      Virtual supervisor software interrupt pending.
    type: RW-R
    reset_value: 0
    definedBy: Smaia
    sw_write(csr_value): |
      if (CSR[mvien].VSSIE == 1'b1) {
        return csr_value;
      }
      return 0;  # Force to zero if mvien bit is disabled
  VSTIP:
    location: 5
    long_name: Virtual Supervisor Timer Interrupt Pending
    description: |
      Virtual supervisor timer interrupt pending.
    type: RW-R
    reset_value: 0
    definedBy: Smaia
    sw_write(csr_value): |
      if (CSR[mvien].VSTIE == 1'b1) {
        return csr_value;
      }
      return 0;  # Force to zero if mvien bit is disabled
  VSEIP:
    location: 9
    long_name: Virtual Supervisor External Interrupt Pending
    description: |
      Virtual supervisor external interrupt pending.
    type: RW-R
    reset_value: 0
    definedBy: Smaia
    sw_write(csr_value): |
      if (CSR[mvien].VSEIE == 1'b1) {
        return csr_value;
      }
      return 0;  # Force to zero if mvien bit is disabled
sw_read(): |
  return value;
sw_write(csr_value): |
  Bits<MXLEN> writable_mask = 0;
  
  // Bits 0-12 are always writable
  writable_mask[12:0] = {13{1'b1}};
  
  // For bits 13-63, check configuration
  for (int i = 13; i <= 63; i++) {
    if (MACHINE_VIRTUAL_INTERRUPTS.include?(i)) {
      writable_mask[i] = 1;
    }
  }
  
  return (value & writable_mask) | (csr_value & ~writable_mask);