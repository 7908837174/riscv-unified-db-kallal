# yaml-language-server: $schema=../../../schemas/inst_schema.json

$schema: "inst_schema.json#"
kind: instruction
name: cm.push
long_name: Create function call stack frame
description: |
  Create stack frame: store `ra` and 0 to 12 saved registers to the stack frame, optionally allocate additional stack space.
  This instruction pushes (stores) the registers in rlist to the memory below the stack pointer,
  and then creates the stack frame by decrementing the stack pointer by stack_adj, including any additional stack space requested by the value of `spimm`.
  --
  Stack Adjustment Calculation:
  --
  stack_adj_base is the minimum number of bytes, in multiples of 16-byte address increments, required to cover the registers in the list.
  `spimm` is the number of additional 16-byte address increments allocated for the stack frame.
  The total stack adjustment represents the total size of the stack frame, which is stack_adj_base added to spimm scaled by 16, as defined above.
definedBy:
  anyOf:
    - Zcmp
assembly: reg_list, -stack_adj
encoding:
  match: 10111000------10
  variables:
    - name: rlist
      location: 7-4
      not: [0, 1, 2, 3]
    - name: spimm
      location: 3-2
access:
  s: always
  u: always
  vs: always
  vu: always
operation(): |
  if (implemented?(ExtensionName::Zcmp) && (CSR[misa].C == 1'b0)) {
    raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
  }

  XReg nreg = (rlist == 15) ? 13 : (rlist - 3);
  XReg stack_additional_adj = (spimm * 16);
  XReg stack_aligned_adj = (nreg * 4 + 15) & ~0xF;
  XReg virtual_address_sp = X[2];
  XReg virtual_address_new_sp = virtual_address_sp - stack_aligned_adj - stack_additional_adj;
  XReg virtual_address_base = virtual_address_sp - (nreg * XLEN);

  write_memory<XLEN>(virtual_address_base +  0*XLEN, X[ 1], $encoding);
  if (nreg > 1) {
    write_memory<XLEN>(virtual_address_base +  1*XLEN, X[ 8], $encoding);
  }
  if (nreg > 2) {
    write_memory<XLEN>(virtual_address_base +  2*XLEN, X[ 9], $encoding);
  }
  if (nreg > 3) {
    write_memory<XLEN>(virtual_address_base +  3*XLEN, X[18], $encoding);
  }
  if (nreg > 4) {
    write_memory<XLEN>(virtual_address_base +  4*XLEN, X[19], $encoding);
  }
  if (nreg > 5) {
    write_memory<XLEN>(virtual_address_base +  5*XLEN, X[20], $encoding);
  }
  if (nreg > 6) {
    write_memory<XLEN>(virtual_address_base +  6*XLEN, X[21], $encoding);
  }
  if (nreg > 7) {
    write_memory<XLEN>(virtual_address_base +  7*XLEN, X[22], $encoding);
  }
  if (nreg > 8) {
    write_memory<XLEN>(virtual_address_base +  8*XLEN, X[23], $encoding);
  }
  if (nreg > 9) {
    write_memory<XLEN>(virtual_address_base +  9*XLEN, X[24], $encoding);
  }
  if (nreg > 10) {
    write_memory<XLEN>(virtual_address_base + 10*XLEN, X[25], $encoding);
  }
  if (nreg > 11) {
    write_memory<XLEN>(virtual_address_base + 11*XLEN, X[26], $encoding);
    write_memory<XLEN>(virtual_address_base + 12*XLEN, X[27], $encoding);
  }

  X[2] = virtual_address_new_sp;
