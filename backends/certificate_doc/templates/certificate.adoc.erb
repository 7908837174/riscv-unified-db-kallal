// Number heading sections (e.g., 1.0, 1.1, etc.)
:sectnums:  

// Add a table of contents for HTML (and VSCode adoc preview)
:toc: left

// Include headings up to 3 levels deep (don't know why 5 gives you this).
:toclevels: 5

//
// Stuff to generate nice wavedrom drawings of instruction and CSR fields
//
:wavedrom: <%= $root %>/node_modules/.bin/wavedrom-cli

// TODO: needs to be changed
:imagesoutdir: images

= <%= cert_model.name %> Certification Requirements Document

[Preface]
== Revision History

History of documentation changes that eventually lead to releases.

[cols="1,1,5"]
|===
| Date | Revision | Changes

<% cert_model.revision_history.each do |rev| -%>
| <%= rev.date %> 
| <%= rev.revision %>
a| <% rev.changes.each do |change| %>
* <%= change %>
<% end -%>
<% end -%>
|===

[Preface]
== Typographic Conventions

CSR field colors::

* Grey fields are reserved (WPRI)
* Green fields are present
* Red fields are defined by the RISC-V ISA but not present

CSR field types::

[%autowidth]
|===
| Abbreviation | Description

<% CsrField::TYPE_DESC_MAP.each do |abbreviation, description| -%>
| <%= abbreviation %>
| <%= description %>
<% end -%>
|===

== Certification Requirements Documents (CRDs)

=== Introduction

A Certification Requirements Document (CRD) lists requirements an implementation must meet
to obtain a specific RVI (RISC-V International) certificate. 
CRDs are developed by the RVI CSC (Certification Steering Committee) organization.
The CRDs refer to and augment information provided in existing ratified RVI standards. 

There are a variety of certificates offered by RVI to accomodate the various RVI standards.
There are certificates for processors, non-processor system IP (e.g., IOMMU), 
and system platforms (processor + system IP) hardware standards.
There are multiple classes of processor certificates available to accomodate the wide range of 
RISC-V implementations from basic microcontrollers to advanced Applications-class processors.

Each CRD has a list of mandatory behaviors along with a list of optional behaviors.
Each certificate has a name and version number that is shared by its associated CRD.
Note that not all behaviors allowed in RISC-V standards are supported by a particular CRD.

=== Naming Scheme

CRDs and certificates have the following naming scheme:

  Format: <name>[*v*<version>]

Where:

* Left & right square braces denote optional.
* Less-than & greater-than signs just separate fields (i.e., they aren't present in the CRD name).
* <name> identifies the type of CRD/certificate (e.g., processor vs. non-processor system IP)
** The <name> is changed when new mandatory behaviors are added to a certificate.
* <version> identifies a particular CRD/certificate release
** Format is <major>[.<minor>[.<patch>]]
** Follows semantic versioning scheme (https://semver.org/)
** The <major> release is updated when certification test changes are made that *could* cause a previously certified
   implementation to now fail. 
   Examples are fixing a test bug or increasing test coverage.
   A <major> release of 0 is used for pre-release versions of a CRD and release versions start with 1.
** The <minor> release is updated when a certificate increases support for optional behaviors.
   Examples are supporting for new optional standards or 
   supporting additional optional behaviors for standards already in a certificate.
** The <patch> release is updated when certification test changes are made that *can't* cause a previously certified
   implementation to now fail or for non-functional changes to documentation.
   Examples are test changes not designed to increase coverage or fixing a documentation typo.
** If omitted, defaults to v1.0.0
** Examples: v1, v1.1, v2.3.1, 0.3.4 (pre-release)

=== Terminology

==== Requirements

[%autowidth]
|===
| Term | Meaning

| MANDATORY | You have to implement it to get a certificate and the certificate tests will cover it
| OPTIONAL | It’s up to you if you implement or not. If you claim to implement it, certificate tests will cover it
| IN-SCOPE | Either MANDATORY or OPTIONAL
| OUT-OF-SCOPE | It’s up to you if you implement or not. If you implement it, it won't be certified but make sure you don’t mess up anything we are certifying.
| INCOMPATIBLE | If you implement it you won’t get a certificate
|===

==== Glossary

[%autowidth]
|===
| Term | Meaning

| CRD | Certification Requirements Document
| N/A | “Not Applicable”
| AKA | “Also Known As”
|===

=== Processor Certificates

Certificates are available for different classes of processors as shown in the table below. 
These documents augment information in the related TSC Profile when available and/or other RVI standards documents 
(e.g., Priv and Unpriv ISA manuals). 
Please refer to the CRDs listed below for detailed certification requirements for the corresponding class of processors.

[%autowidth]
|===
| Certificate | CRD | TSC Profile | Description

| MC100-series | TBD | None | Minimal microcontroller that runs low-level software on an RTOS or bare-metal (no virtual memory)
| MC200-series | TBD | RVM | Advanced microcontroller
| RVB-series | TBD | RVB23 | Applications-class processors running Bespoke rich operating systems (e.g., Yocto Linux)
| RVA-series | TBD | RVA23 | Applications-class processors running standard rich operating systems (e.g., commercial Linux distributions, Android)
|===

=== RISC-V Extensions

All optional extensions of the RISC-V ISA not explicitly mentioned by the individual CRDs are OUT-OF-SCOPE.
Only ratified extensions are candidates for certification. 
This means all custom extensions are OUT-OF-SCOPE. 
This is independent of where a custom extension opcodes are located 
(i.e., either in the custom opcode space or standard & reserved opcode space).

=== CSR Fields

==== Definition of CSR Fields

[%autowidth]
|===
| Field Type | Read Value After Writing Illegal Value | Read Value Function Of | Illegal Instruction Exception | Priv ISA Manual Quote

| WLRL | Any deterministic legal or illegal value | Value before write and illegal value written | Optional 
| Implementations are permitted but not required to raise an illegal-instruction exception if an instruction attempts to write a non-supported value to a WLRL field. Implementations can return arbitrary bit patterns on the read of a WLRL field when the last write was of an illegal value, but the value returned should deterministically depend on the illegal written value and the value of the field prior to the write.
| WARL | Any deterministic legal value | Any architectural hart state | Prohibited
| Implementations will not raise an exception on writes of unsupported values to a WARL field. Implementations can return any legal value on the read of a WARL field when the last write was of an illegal value, but the legal value returned should deterministically depend on the illegal written value and the architectural state of the hart.
| WPRI | 0 | Nothing | Not specified
| Some whole read/write fields are reserved for future use. Implementations that do not furnish these fields must make them read-only zero.
|===

==== Treatment of CSR Fields

*WARL (Write Anything, Read Legal)*:

The Priv ISA requires reads of WARL fields to return some implementation-dependent deterministic legal value 
after the field is written with an illegal value. 
Certifying such behaviors is expensive and provides low value for a certificate since software can’t rely 
on a particular behavior from one implementation to another.

CSC processor CRDs define writes to WARL fields of illegal values to be OUT-OF-SCOPE unless otherwise stated 
(i.e., certification tests will only ever write legal values to WARL fields except for the special cases listed below).
When not OUT-OF-SCOPE, the required behavior is defined as this might be more constrained in implementations than 
in the standard.

The following special cases for WARL are supported when explicitly listed in the corresponding CRD CSR field requirements:
1. Probing for Field Width
* Some WARL fields are variable length such as the ASID field in the virtual memory extension.
* Here’s the algorithm recommended to discover the ASID width:
** The number of implemented ASID bits, termed ASIDLEN, may be determined by writing one to every bit position in 
   the ASID field, then reading back the value in the satp CSR to see which bit positions in the ASID field hold a one.
* The RVCP-provided certification materials (certification tests, certification reference models) can map writes of
  illegal values to the ASID field to the corresponding read value as long as they are provided the ASIDLEN value
  for an implementation.
2. Probing for Options
* E.g., Writable misa bits
3. Allowed values are a function of extension presence and/or their parameters
* E.g., satp.mode legal write values

*WLRL (Write Legal, Read Legal)*:

The Priv ISA requires reads of WLRL fields to return some implementation-dependent deterministic arbitrary value
after the field is written with an illegal value. 
Certifying such behaviors is expensive and provides low value for a certificate since software can’t rely 
on a particular behavior.  
CSC processor CRDs define writes to WLRL fields of illegal values to be OUT-OF-SCOPE unless otherwise stated 
(i.e., certification tests will only ever write legal values to WLRL fields).

*WPRI (Write Preserve, Read Ignore)*:

The Priv ISA requires reads of WPRI fields to return a value of 0. 
Such WPRI fields are always unimplemented by definition. 
Certification tests are aware of which fields in the CSRs are WPRI and normally write them with 0 but will 
also write them with ~0 (all ones) and ensure that reads return 0 in both cases. 
It is OUT-OF-SCOPE for certification tests to write all possible values of WPRI fields 
(especially if they are more than just a few bits) and certification tests aren’t designed to be comprehensive 
verification test suites anyways.

=== System IP CRDs

TBD

=== Platform CRDs
TBD

== <%= cert_class.name %> and <%= cert_model.name %> Introduction

<%= cert_class.introduction %>

=== <%= cert_class.name %> Naming Scheme

<%= cert_class.naming_scheme %>

=== <%= cert_class.name %> Class Description

<%= cert_class.description %>

=== <%= cert_model.name %> Description

<%= cert_model.description %>

=== Related Specifications

[cols="2,2,3,3,3"]
|===
| Certificate Model | TSC Profile | Unpriv ISA Manual | Priv ISA Manual | Debug Manual

| <%= cert_model.name %>
| <%= cert_model.tsc_profile.nil? ? "No profile" : cert_model.tsc_profile.marketing_name %>
| <%= cert_model.unpriv_isa_manual_revision %>
| <%= cert_model.priv_isa_manual_revision %>
| <%= cert_model.debug_manual_revision %>
|===

=== Privileged Modes

|===
| M | S | U | VS | VU

| <% if cert_class.mandatory_priv_modes.include?('M') -%> MANDATORY <% else -%> OUT-OF-SCOPE <% end -%>
| <% if cert_class.mandatory_priv_modes.include?('S') -%> MANDATORY <% else -%> OUT-OF-SCOPE <% end -%>
| <% if cert_class.mandatory_priv_modes.include?('U') -%> MANDATORY <% else -%> OUT-OF-SCOPE <% end -%>
| <% if cert_class.mandatory_priv_modes.include?('VS') -%> MANDATORY <% else -%> OUT-OF-SCOPE <% end -%>
| <% if cert_class.mandatory_priv_modes.include?('VU') -%> MANDATORY <% else -%> OUT-OF-SCOPE <% end -%>

|===

<<<
== Extensions

Any RISC-V extension not listed in this section is OUT-OF-SCOPE so the <%= cert_model.name %>
certificate doesn't cover its associated behaviors.

<% ExtensionPresence.presence_types_obj.each do |presence_obj| -%>

=== <%= presence_obj.to_s.capitalize %> Extensions

<% ext_reqs = cert_model.in_scope_ext_reqs(presence_obj) -%>
<% if ext_reqs.empty? -%>
None
<% else -%>
[%autowidth]
|===
| Requirement ID | Extension | Version | Long Name | Note

<% ext_reqs.sort.each do |ext_req| -%>
<% ext = arch_def.extension(ext_req.name) -%>
| <%= ext_req.req_id %> 
| <<ext-<%= ext_req.name %>-def,<%= ext_req.name %>>> 
| <%= ext_req.version_requirement %>
| <%= ext.nil? ? "" : ext.long_name %>
| <%= ext_req.note.nil? ? "" : ext_req.note %>
<% end # each ext_req -%>
|===
<% end # if empty ext_reqs -%>

<% cert_model.extra_notes_for_presence(presence_obj)&.each do |extra_note| -%>
NOTE: <%= extra_note.text %>

<% end # each extra_note -%>

<% end # each possible presence -%>

<% unless cert_model.recommendations.empty? -%>
=== Recommendations

Recommendations are not strictly mandated but are included to guide implementers making design choices.

<% cert_model.recommendations.each do |recommendation| -%>
<%= recommendation.text %>
<% end # each recommendation -%>
<% end # unless recommendations empty -%>

<<<
== Implementation-dependencies

RISC-V standards support many implementation-defined parameters. In many cases, there
are no names associated with these parameters. Names are defined in this section when
not provided in the associated standard.

=== IN-SCOPE Parameters

These implementation-dependent options defined by MANDATORY or OPTIONAL extensions are IN-SCOPE. 
An implementation must abide by the "Allowed Value(s)" to obtain a certificate.
If the "Allowed Value(s)" is "Any" then any value allowed by the type is acceptable.

<% if cert_model.all_in_scope_ext_params.empty? -%>
None
<% else -%>
[cols="4,2,1,1,2"]
|===
| Parameter | Type | Allowed Value(s) | Extension(s) | Note

<% cert_model.all_in_scope_ext_params.sort.each do |in_scope_ext_param| -%>
<% param = in_scope_ext_param.param -%>
<% exts = cert_model.all_in_scope_exts_with_param(param) -%>
| <%= param.name_potentially_with_link(exts) %>
| <%= param.schema_type %>
| <%= in_scope_ext_param.allowed_values %>
| <% exts.sort.each do |ext| -%><<ext-<%= ext.name %>-param-<%= param.name %>-def,<%= ext.name %>>> <% end # do ext -%>
a| <%= in_scope_ext_param.note %>
<% end # do -%>
|===
<% end # if table -%>

=== OUT-OF-SCOPE Parameters

These implementation-dependent options defined by MANDATORY or OPTIONAL extensions are OUT-OF-SCOPE. 
There are no restrictions on their values for certification purposes because the certificate 
doesn't cover the behavior of the associated RISC-V standard as a function of these parameters.

<% if cert_model.all_out_of_scope_params.empty? -%>
None
<% else -%>
[%autowidth]
|===
| Parameters | Type | Extension(s)

<% cert_model.all_out_of_scope_params.sort.each do |param| -%>
<% exts = cert_model.all_in_scope_exts_without_param(param) -%>
| <%= param.name_potentially_with_link(exts) %>
| <%= param.schema_type %>
| <% exts.sort.each do |ext| -%><<ext-<%= ext.name %>-param-<%= param.name %>-def,<%= ext.name %>>> <% end # do ext -%>

<% end # do -%>
|===
<% end # if table -%>

== Instruction Summary

<%
  insts = cert_model.in_scope_extensions.map { |ext_cert_model| ext_cert_model.instructions }.flatten.uniq
  insts.sort_by!(&:name)
-%>

[%autowidth]
|===
| Name | Long Name

<% insts.each do |inst| -%>
| <%= link_to_inst(inst.name) %>
| <%= inst.long_name %>
<% end # do -%>
|===

== CSR Summary

<%
  csrs = cert_model.in_scope_ext_reqs.map { |ext_req| ext_req.csrs(arch_def) }.flatten.uniq
-%>

=== By Name

[%autowidth]
|===
| Name | Long Name | Address | Mode | Primary Extension

<% csrs.sort_by!(&:name).each do |csr| -%>
| <<csr-<%= csr.name %>-def,<%= csr.name %>>>
| <%= csr.long_name %>
| <%= "0x#{csr.address.to_s(16)}" %>
| <%= csr.priv_mode %>
| <%= csr.primary_defined_by %>
<% end # do -%>
|===

=== By Address

[%autowidth]
|===
| Address | Mode | Name | Long Name | Primary Extension

<% csrs.sort_by!(&:address).each do |csr| -%>
| <%= "0x#{csr.address.to_s(16)}" %>
| <%= csr.priv_mode %>
| <<csr-<%= csr.name %>-def,<%= csr.name %>>>
| <%= csr.long_name %>
| <%= csr.primary_defined_by %>
<% end # do -%>
|===

<% unless cert_model.requirement_groups.empty? -%>
== Additional Requirements

This section contains requirements in addition to those already specified related to extensions and parameters.
These additional requirements are organized as groups of related requirements.

<% cert_model.requirement_groups.each do |group| -%>
=== <%= group.name %>

<%= group.description %>

<% unless group.when.nil? -%>
[IMPORTANT]
<%= group.name %> requirements only apply when <%= group.when_pretty %>.
<% end -%>

[%autowidth]
|===
| Req Number | Description

<% group.requirements.each do |req| -%>
| <%= req.name %>
a| <%= req.description %>
<% unless req.when.nil? -%>
[IMPORTANT]
Requirement <%= req.name %> only apply when <%= req.when_pretty %>.
<% end -%>
<% end -%>
|===

<% end -%>
<% end # unless requirement_groups.empty? -%>

<<<
[appendix]
== Extension Details
<% cert_model.in_scope_ext_reqs.sort.each do |ext_req| -%>
<% ext = arch_def.extension(ext_req.name) -%>

[[ext-<%= ext_req.name %>-def]]
=== Extension <%= ext_req.name %> +
<%= ext.nil? ? "" : "*Long Name*: " + ext.long_name + " +" %>

*Version Requirement*: <%= ext_req.version_requirement %> +

<% ext.versions.each do |v| -%>
<%= v.version %>::
  State:::
    <%= v.state %>
  <% if v.state == "ratified" -%>
  Ratification date:::
    <%= v.ratification_date %>
  <% end # if %>
  <% if v.changes.size > 0 -%>
  Changes:::

    <% v.changes.each do |c| -%>
    * <%= c %>  
    <% end -%>

  <% end -%>
  <% unless v.url.nil? -%>
  Ratification document:::
    <%= v.url %>
  <% end -%>
  <% if v.implications.size > 0 -%>
  Implies:::
    <% v.implications.each do |i| -%>
    * `<%= i.name %>` version <%= i.version %>
    <% end -%>
  <% end -%>
<% end -%>

==== Synopsis

:leveloffset: +3

<%= ext.description %>

:leveloffset: -3

<% unless ext_req.note.nil? -%>
[NOTE]
--
<%= ext_req.note %>
--
<% end -%>

// TODO: GitHub issue 92: Use version specified by each profile.
<% insts = arch_def.instructions.select { |i| i.defined_by?(ext.min_version) } -%>
<% unless insts.empty? -%>
==== Instructions

The following instructions are added by this extension:

[cols="1,3"]
|===
<% insts.sort.each do |inst| -%>
| <%= link_to_inst(inst.name) %>
| *<%= inst.long_name %>*
<% end -%>
|===
<% end -%>

<% unless cert_model.in_scope_ext_params(ext_req).empty? -%>
==== IN-SCOPE Parameters

<% cert_model.in_scope_ext_params(ext_req).sort.each do |ext_param| -%>
[[ext-<%= ext_req.name %>-param-<%= ext_param.name %>-def]]
<%= ext_param.name %> &#8658; <%= ext_param.param.schema_type %>::
+
--
<%= ext_param.param.desc %>
--
<% end # do ext_param -%>
<% end # unless table -%>

<% unless cert_model.out_of_scope_params(ext_req.name).empty? -%>
==== OUT-OF-SCOPE Parameters

<% cert_model.out_of_scope_params(ext_req.name).sort.each do |param| -%>
[[ext-<%= ext_req.name %>-param-<%= param.name %>-def]]
<%= param.name %> &#8658; <%= param.schema_type %>::
+
--
<%= param.desc %>
--
<% end # do param -%>
<% end # unless table -%>
<% end # do ext_req -%>

<<<
[appendix]
== Instruction Details

<%=
  insts = portfolio.in_scope_ext_reqs.map { |ext_req| ext_req.implemented_instructions }.flatten.uniq
  insts.sort_by!(&:name)
-%>

<% insts.each do |inst| -%>
<<<
<%= anchor_for_inst(inst.name) %>
=== <%= inst.name %>

*<%= inst.long_name %>*

This instruction is defined by:

<%= inst.defined_by.to_asciidoc %>

==== Encoding

<% if inst.multi_encoding? -%>
[NOTE]
This instruction has different encodings in RV32 and RV64.

====
RV32::
+
[wavedrom, ,svg,subs='attributes',width="100%"]
....  
<%= JSON.dump inst.wavedrom_desc(32) %>
....

RV64::
+
[wavedrom, ,svg,subs='attributes',width="100%"]
....  
<%= JSON.dump inst.wavedrom_desc(64) %>
....
====
<% else -%>
[wavedrom, ,svg,subs='attributes',width="100%"]
....  
<%= JSON.dump inst.wavedrom_desc(inst.base.nil? ? 32 : inst.base) %>
....
<% end -%>

==== Synopsis

<%= inst.description %>

==== Access
<% if cert_model.in_scope_extensions.any? { |e| e.name == "H" } -%>
[cols="^,^,^,^,^"]
<% else -%>
[cols="^,^,^"]
<% end -%>
|===
| M | <% if cert_model.in_scope_extensions.any? { |e| e.name == "H" } -%>HS<% else -%>S<% end -%> | U <% if cert_model.in_scope_extensions.any? { |e| e.name == "H" } -%> | VS | VU <% end -%>

| [.access-always]#Always#
| [.access-<%=inst.access['s']%>]#<%= inst.access['s'].capitalize %>#
| [.access-<%=inst.access['u']%>]#<%= inst.access['u'].capitalize %>#
<% if cert_model.in_scope_extensions.any? { |e| e.name == "H" } %>
| [.access-<%=inst.access['vs']%>]#<%= inst.access['vs'].capitalize %>#
| [.access-<%=inst.access['vu']%>]#<%= inst.access['vu'].capitalize %>#
<% end %>
|===

<% if inst.access_detail? -%>
<%= inst.access_detail %>
<% end -%>

==== Decode Variables

<% if inst.multi_encoding? -%>
====
RV32::
+
[source.idl]
----
<% inst.decode_variables(32).each do |d| -%>
<%= d.sext? ? 'signed ' : '' %>Bits<<%= d.size %>> <%= d.name %> = <%= d.extract %>;
<% end -%>
----

RV64::
+
[source,idl]
----
<% inst.decode_variables(64).each do |d| -%>
<%= d.sext? ? 'signed ' : '' %>Bits<<%= d.size %>> <%= d.name %> = <%= d.extract %>;
<% end -%>
----
====
<% else -%>
[source,idl]
----
<% inst.decode_variables(inst.base.nil? ? 32 : inst.base).each do |d| -%>
<%= d.sext? ? 'signed ' : '' %>Bits<<%= d.size %>> <%= d.name %> = <%= d.extract %>;
<% end -%>
----
<% end -%>

==== Execution

<% xlens = inst.base.nil? ? [32, 64] : [inst.base] -%>

<% if inst.key?("operation()") -%>
[source,idl,subs="specialchars,macros"]
----
<%= inst.operation_ast(arch_def.symtab).gen_adoc %>
----
<% end -%>

==== Exceptions

<%- exception_list = inst.reachable_exceptions_str(arch_def.symtab) -%>
<%- if exception_list.empty? -%>
This instruction does not generate synchronous exceptions.
<%- else -%>
This instruction may result in the following synchronous exceptions:

  <%- exception_list.sort.each do |etype| -%>
  * <%= etype %>
  <%- end -%>

<%- end -%>


<% end -%>

<<<
[appendix]
== CSR Details

<%
  csrs = cert_model.in_scope_ext_reqs.map { |ext_req| ext_req.csrs(arch_def) }.flatten.uniq
  csrs.sort_by!(&:name)
-%>

<% csrs.each do |csr| -%>
<<<
[[csr-<%= csr.name %>-def]]
=== <%= csr.name %>

*<%= csr.long_name %>*

<% unless csr.base.nil? -%>
[NOTE]
--
`<%= csr.name %>` is only defined in RV<%= csr.base %>.
--
<% end -%>

<%= csr.description %>

==== Attributes
[%autowidth]
|===
h| CSR Address    | <%= "0x#{csr.address.to_s(16)}" %>
<% if csr.priv_mode == 'VS' -%>
h| Virtual CSR Address    | <%= "0x#{csr.virtual_address.to_s(16)}" %>
<% end -%>
h| Defining extension a| <%= csr.defined_by.to_asciidoc %>
<% if csr.dynamic_length?(arch_def) -%>
h| Length         | <%= csr.length_pretty(arch_def) %>
<% else -%>
h| Length         | <%= csr.length_pretty(arch_def) %>
<% end -%>
h| Privilege Mode | <%= csr.priv_mode %>
|===


==== Format
<% unless csr.dynamic_length?(arch_def) || csr.implemented_fields(arch_def).any? { |f| f.dynamic_location?(arch_def) } -%>
<%# CSR has a known static length, so there is only one format to display -%>
.<%= csr.name %> format
[wavedrom, ,svg,subs='attributes',width="100%"]
....
<%= JSON.dump csr.wavedrom_desc(arch_def, csr.base.nil? ? 32 : csr.base, optional_type: 2) %>
....
<% else -%>
<%# CSR has a dynamic length, or a field has a dynamic location,
    so there is more than one format to display -%>
This CSR format changes dynamically with XLEN.

.<%= csr.name %> Format when <%= csr.length_cond32 %>
[wavedrom, ,svg,subs='attributes',width="100%"]
....
<%= JSON.dump csr.wavedrom_desc(arch_def, 32, optional_type: 2) %>
....

.<%= csr.name %> Format when <%= csr.length_cond64 %>
[wavedrom, ,svg,subs='attributes',width="100%"]
....
<%= JSON.dump csr.wavedrom_desc(arch_def, 64, optional_type: 2) %>
....


<% end # unless dynamic length -%>

==== Field Summary

// use @ as a separator since IDL code can contain |
[%autowidth,separator=@,float="center",align="center",cols="^,<,<,<",options="header",role="stretch"]
|===
@ Name @ Location @ Type @ Reset Value

<%- csr.implemented_fields(arch_def).each do |field| -%>
@ xref:<%=csr.name%>-<%=field.name%>-def[`<%= field.name %>`]
a@
<%- if field.dynamic_location?(arch_def) -%>

[when,"<%= field.location_cond32 %>"]
--
<%= field.location_pretty(arch_def, 32) %>
--

[when,"<%= field.location_cond64 %>"]
--
<%= field.location_pretty(arch_def, 64) %>
--

<%- else -%>
<%= field.location_pretty(arch_def) %>
<%- end -%>
a@

--
<%= field.type_pretty(arch_def.symtab) %>
--

a@

--
<%= field.reset_value_pretty(arch_def) %>
--

<%- end -%>
|===

==== Fields

<%- if csr.implemented_fields(arch_def).empty? -%>
This CSR has no fields. However, it must still exist (not cause an `Illegal Instruction` trap) and always return zero on a read.
<%- else -%>

<%- csr.implemented_fields(arch_def).each do |field| -%>
[[<%=csr.name%>-<%=field.name%>-def]]
===== `<%= field.name %>`

<%- if !field.defined_in_all_bases? -%>
IMPORTANT: <%= field.name %> is only defined in <%= field.base32_only? ? "RV32" : "RV64" %> (`<%= field.base32_only? ? field.location_cond32 : field.location_cond64 %>`)
<%- end -%>

****
Location::
<%= field.location_pretty(arch_def) %>

Description::
<%= field.description.gsub("\n", " +\n") %>

Type::
<%= field.type_pretty(arch_def.symtab) %>

Reset value::
<%= field.reset_value_pretty(arch_def) %>

****

<%- end -%>
<%- end -%>

<%- if csr.implemented_fields(arch_def).map(&:has_custom_sw_write?).any? -%>
==== Software write

This CSR may store a value that is different from what software attempts to write.

When a software write occurs (_e.g._, through `csrrw`), the following determines the
written value:

[idl]
----
<%- csr.implemented_fields(arch_def).each do |field| -%>
<%- if field.has_custom_sw_write? -%>
<%= field.name %> = <%= field["sw_write(csr_value)"] %>
<%- else -%>
<%= field.name %> = csr_value.<%= field.name %>
<%- end -%>
<%- end -%>
----
<%- end -%>

<%- if csr.has_custom_sw_read? -%>
==== Software read

This CSR may return a value that is different from what is stored in hardware.

[source,idl,subs="specialchars,macros"]
----
<%= csr.sw_read_ast(arch_def.symtab).gen_adoc %>
----
<%- end -%>

<% end # do csrs -%>